# Семантика языковых конструкций

## 1. Логические значения и условия

1. Отдельный тип `bool` отсутствует.
   Любое **ненулевое целое число** (`int`) интерпретируется как **истина**,
   значение `0` — как **ложь**.

2. Логические литералы:

   * `true`  — синтаксический сахар для целого литерала `1`
   * `false` — синтаксический сахар для целого литерала `0`

3. Все операции сравнения (`== != < > <= >=`) и логические операции (`&& || !`)
   возвращают `1` (истина) или `0` (ложь) типа `int`.

4. Логические операторы `&&` и `||` используют **короткозамкнутые вычисления**
   (short-circuit evaluation): правый операнд вычисляется только если результат не определён левым.

## 2. Операторы сравнения

| Типы операндов      | Семантика                                     |
| ------------------- | --------------------------------------------- |
| `int`    с `int`    | Сравнение по численному значению              |
| `float`  с `float`  | Сравнение по значению IEEE 754                |
| Разные типы         | Запрещено (ошибка проверки типов)             |

Операторы `==` и `!=` допустимы для всех типов.

## 3. Ветвления if … else

1. Условие должно быть **числовым выражением** (`numeric_expression`).
   Результат приводится к истине/лжи по правилу п.1.

2. При истинном условии выполняется блок сразу после `if`,
   при ложном — `else` (если он есть).

3. `else` всегда привязывается к **ближайшему предыдущему `if`**
   (dangling else разрешается в пользу ближайшего `if`).

4. Цепочки `else if` отсутствуют.

5. `if` — это **инструкция**, а не выражение.
   Она не возвращает значение.

## 4. Циклы

### 4.1 while

```text
while (cond) { … }
```

* Условие — числовое выражение.
* Выполняется, пока условие истинно.
* Проверка условия происходит перед каждой итерацией.
* while — инструкция, не возвращает значение.

### 4.2 for

```text
for (init; condition; update) { … }
```

Эквивалентно:

```text
init;
while (condition) 
{
    { … }
    update;
}
```

* `init` — объявление переменной или присваивание (один раз).
* `condition` — опционально; если отсутствует — считается истинным.
* `update` — опциональное присваивание/инкремент.
* for — инструкция.

### 4.3 break и continue

* `break;` — завершает ближайший while или for.
* `continue;` — переходит к следующей итерации (для for сначала выполняется update).
* Использование вне циклов — ошибка.

## 5. Области видимости

* Лексическая (статическая) область видимости.
* Новые области создаются телом функции `fn … { … }`
* Переменные и функции — разные пространства имён.
* Функция захватывает переменные внешней области видимости только через параметры 
* Зарезервированные имена нельзя использовать как идентификаторы.

## 6. Параметры функций и вызовы

* Передача параметров по значению.
* Формальные параметры — изменяемые локальные переменные.
* Количество и типы аргументов должны точно совпадать.
* Аргументы вычисляются слева направо.

## 7. Возврат из функции (return)

* Функции `int/float/str` обязаны иметь `return` на всех путях.
* Функции `void` могут завершаться без `return` (неявный void).

## 8. Рекурсия

* Рекурсия поддерживается
* Замыкания не поддерживаются 

## 9. Присваивание и переменные
* Переменные и функции используют разные пространство имён
* Левая часть присваивания — только идентификатор объявленной переменной.
* Использование неинициализированной переменной — ошибка.
* Все переменные изменяемые.

## 10. Точка входа

* Обязательна функция `fn main() { … }` без параметров и без типа возврата.
* Выполнение начинается с неё.
* Код возврата ОС — 0.
