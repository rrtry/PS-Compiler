# Семантика типов

## Встроенные типы

| Тип      | Описание                                            |
|----------|-----------------------------------------------------|
| `int`    | целое знаковое 64-бит                               |
| `float`  | IEEE 754 binary64 (double)                          |
| `string` | неизменяемая Unicode-строка, хранение UTF-8         |
| `void`   | отсутствие значения (только для функций)            |

## Логические значения
- Нет отдельного типа `bool`
- `true`  → синтаксический сахар для `1` (int)
- `false` → синтаксический сахар для `0` (int)
- Любое ненулевое `int` считается истинным в условиях

## Преобразования

### Неявные
- `int → float` (при арифметических операциях)

### Явные (встроенные функции преобразования)
- `int(x)`   — из float или string в int (отбрасывание дробной части)
- `float(x)` — из int или string в float
- `str(x)`   — любое значение → string

------------------------------------------------------------------------

## 2. Литералы

### 2.1. Целые числа (int)

Поддерживаются литералы:

-   десятичные: `42`
-   шестнадцатеричные: `0x2A`
-   двоичные: `0101010`

### 2.2. Числа с плавающей точкой (float)

Примеры литералов: `3.14`, `0.5`, `-12.75`

### 2.3. Строки (string)

Строковые литералы заключаются в кавычки `"...'"`:

-   `"Hello"`
-   `"Привет мир"`

Строки поддерживают Unicode, хранятся в UTF‑8.

------------------------------------------------------------------------

## 3. Операторы

### 3.1. Арифметические операторы (`+`, `-`, `*`, `/`, `%`, `^`, `**`)

-   Если операнды `int` и `int` → результат `int`.
-   Если один из операндов `float` → второй приводится к `float`,
    результат `float`.
-   `%` допустим только для `float` и `int`.

### 3.2. Операторы сравнения (`<`, `>`, `<=`, `>=`, `==`, `!=`)

Результат --- логическое значение (`1` = true, `0` = false).

### 3.3. Логические операторы (`&&`, `||`, `!`)

Принимают значения, приводимые к `true` / `false`.

### 3.4. Строковые операции

-   Конкатенация: `sconcat(a, b)`
-   Подстрока: `substr(s, start, length)`

------------------------------------------------------------------------

## 4. Переменные

### 4.1. Объявление переменных

    let x: int = 40;
    let y: float = 3.33;
    let name: string = "Bob";

### 4.2. Правила семантики

-   Если тип указан → переменная должна получить значение этого типа.
-   Если тип не указан → выводится по значению при первом присваивании.
-   После первого присваивания тип становится фиксированным.

### 4.3. Присваивание

    x = expr;

Тип выражения должен подходить под тип переменной.

------------------------------------------------------------------------

## 5. Преобразования типов

### 5.1. Неявные преобразования

-   `int → float`

### 5.2. Явные преобразования

-   `int(x)` --- преобразует строку или float в int.
-   `float(x)` --- преобразует строку или int в float.
-   `str(x)` --- преобразует любое значение в string.

#### Пример

    let x: int = 54;
    let s = str(x);
    let f = float(x);

------------------------------------------------------------------------

## 6. Тип int --- детали

-   Размер: **64 бита** (знаковый).
-   Максимум: `9_223_372_036_854_775_807`
-   Минимум: `−9_223_372_036_854_775_808`
-   Полная поддержка арифметики.

------------------------------------------------------------------------

## 7. Тип float --- детали

-   Формат: **IEEE 754 binary64**.
-   Поддержка всех арифметических операторов.
-   Преобразование в int:

    6.5 → 6

------------------------------------------------------------------------

## 8. Тип string --- детали

-   Unicode, хранится как UTF‑8.
-   Конкатенация --- `sconcat(a, b)`
-   Подстрока --- `substr(a, start, length)`
-   Сравнение по Unicode‑кодам символов
-   Не является выражением

------------------------------------------------------------------------

## print и input
- `prints(expr: string)` — выводит строку
- Чтобы вывести число: `print(x)`
- `input()` — считывает строку

## 9. Примеры программ

### ReverseString

```
fn reverse(s: str): str
{
    let len = strlen(s);
    let result = """";

    let i = len - 1;
    while (i >= 0) 
    {
        let ch = substr(s, i, 1);
        result = sconcat(result, ch);
        i = i - 1;
    }

    return result;
}

let text = input();
let reversed = reverse(text);
prints(reversed);
```


### FizzBuzz
```
let x = 1;
while (x) 
{
    let n = stoi(input());
    if (n == 0) 
    {
        break;
    }

    if (n % 15 == 0) 
    {
        prints(""FizzBuzz"");
        continue;
    }
    if (n % 3 == 0) 
    {
        prints(""Fizz"");
        continue;
    }
    if (n % 5 == 0) 
    {
        prints(""Buzz"");
        continue;
    }
    prints(itos(n));
}
```


### CountVowels

```
"fn is_vowel(ch: str): int
{
    if (ch == ""A"" || ch == ""E"" || ch == ""I"" || ch == ""O"" || ch == ""U"" || ch == ""Y"") 
    {
        return 1;
    }
    if (ch == ""a"" || ch == ""e"" || ch == ""i"" || ch == ""o"" || ch == ""u"" || ch == ""y"") 
    {
        return 1;
    }
    return 0;
}

fn count_vowels(s: str): int 
{
    let count = 0;
    let len = strlen(s);
    let i = 0;

    while (i < len) 
    {
        let sub = substr(s, i, 1);
        if (is_vowel(sub)) 
        {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = input();
let vowels = count_vowels(text);
prints(itos(vowels));
```