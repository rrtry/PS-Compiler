
# Спецификация языка

## 1. Пример программы

```
// Пример программы

fn main() 
{
let a: int;
let b: int;
a = int(input());
b = int(input());
let sum = a + b;
print(sum);
}
``` 

## 2. Ключевые особенности языка
- Язык динамически типизированный — тип переменной определяется по значению, но в объявлениях параметров функций и переменных указываются ожидаемые типы (int, float) для проверки совместимости.  
- Все переменные изменяемые (mutable).  
- Переменные объявляются через `let` с необязательным указанием типа .  
- Ввод и вывод реализуются встроенными функциями `input()` и `print()`.  
- Инструкции выполняются последовательно внутри функций.  
- Поддерживаются комментарии:  
  - Однострочные: `// ...`  
  - Многострочные: `/* ... */`  
- Каждая инструкция завершается точкой с запятой `;`.  
- Точка входа — функция `main()`. Выполнение программы начинается с неё.  
- Область видимости переменных ограничена телом функции или блока `{ ... }`.  
- Пользовательские функции объявляются до `main()` с обязательным указанием возвращаемого типа; `main()` не требует указания типа возврата.
- Поддерживаются пользовательские функции с параметрами и возвращаемым типом.
- Ветвления (if-else) и циклы (while, for) реализованы как инструкции.
- Логические операторы (&&, ||, !) возвращают 1 (true) или 0 (false).
- Порядок вычисления аргументов при вызове функции — слева направо.
- Функции без параметров допускаются.
- Процедуры (функции без возвращаемого значения) поддерживаются через специальный тип void.
- Встроенные функции: input(var) (ввод в переменную, поддерживает int/float), print(expr) (вывод значения).


## 3. Семантические правила
| Правило | Описание |
|---------|----------|
| Переменные должны быть объявлены перед использованием | `x = 10;` без `let` — ошибка |
| Повторное объявление переменной в одной области видимости запрещено | `let x = 1; let x = 2;` — ошибка |
| Имя переменной не может совпадать с ключевыми словами | `fn, let, print, input, return, main` и др — запрещено |
| Область видимости переменных ограничена блоком `{ ... }` | — |
| Функция `main()` обязательна | С неё начинается выполнение программы |
| Все функции возвращают значение | — |
| `Pi` и `Euler` — зарезервированные идентификаторы | — |
| Имена регистрозависимы | `count` ≠ `Count` |
| Висячий `else (dangling else)` разрешается прикреплением `else` к ближайшему `if` без вложенного `if` | Пример: `if (c1) if (c2) s1; else s2;` — else относится к внутреннему `if` |
| Аргументы функций вычисляются слева направо| | — |
| `break` и `continue` работают в циклах (`while`, `for`) | - |


## 4. Виды инструкций

В языке используются только полезные инструкции — те, которые выполняют действия (создают переменные, изменяют значения, выполняют ввод/вывод и т.д.).  
Бесполезные выражения запрещены:

```
x + 10;    // Ошибка — выражение ничего не делает
```

**Допустимые типы инструкций:**
| Тип | Пример | Назначение |
|-----|--------|------------|
| Объявление переменной | `let x = 10;` | Создаёт новую переменную (с возможным начальными значением) |
| Присваивание | `x = x + 1;` | Изменяет значение существующей переменной |
| Ввод | `input(x);` | Считывает значение с клавиатуры и сохраняет в переменную |
| Вывод | `print("x);` | Выводит  значения на экран |
| Возврат | `return x;` | Завершает выполнение функции, возвращая значение |
| Ветвление | `if (cond) { ... } else if(cond) {...} else { ... }` | Условное выполнение |
| Цикл while | `while (cond) { ... }` | Цикл с условием | 
| Цикл for | `for (init, cond, update) { ... }` | Цикл с итерацией по диапазону значений |
| Break | `break;` | Прерывание цикла |
| Continue | `continue;` | Пропуск тела до следующей итерации |

## 5. Структура программы

Программа состоит из набора определений функций, точкой входа — `main()`.

```ebnf

program          = { function_definition } , entry_point ;
entry_point      = "fn" , "main" , "(" , [ parameter_list ] , ")" , block ;
function_definition = "fn" , identifier , "(" , [ parameter_list ] , ")" , ":" , type , block ;
parameter_list   = parameter , { "," , parameter } ;
parameter        = identifier , ":" , type ;
type             = "int" | "float" | "string" | "void" ;
block            = "{" , { statement } , "}" ;
```

## 6. Инструкции

```
statement =
    variable_declaration , ";"
  | assignment           , ";"
  | function_call        , ";"
  | return_statement     , ";"
  | if_statement
  | while_statement
  | for_statement
  | "break"  , ";"
  | "continue" , ";"
  ;

```

### Объявление переменной

*initializer может быть выражением для числовых типов, или строковым литералом / string-специфичной конструкцией для string.*

```
variable_declaration = "let" , identifier , [ ":" , type ] , [ "=" , initializer ] ;

initializer =
      numeric_expression          (* для int/float *)
    | string_expression           (* для string *)
    ;
```

Создаёт новую переменную. Если указано выражение — оно вычисляется, и результат присваивается переменной.
Тип необязателен (динамическая типизация с проверкой)

### Присваивание

```
assignment = identifier , "=" , ( numeric_expression | string_expression ) ;
```

Изменяет значение существующей переменной.
Присваивание не является выражением — это отдельная инструкция.

### Вызов функции

```
function_call = identifier , "(" , [ argument_list ] , ")" ;

argument_list = argument , { "," , argument } ;

argument =
      numeric_expression
    | string_expression;

```

### Возврат из функции

```
return_statement = "return" , [ return_value ] , ";" ;

return_value =
      numeric_expression          (* для int/float *)
    | string_expression           (* для string *)
    ;
```
Все пользовательские функции (кроме void) обязаны иметь return.

### Ветвление if-else

```
if_statement =
    "if" , "(" , numeric_expression , ")" , block ,
    { "else" , "if" , "(" , numeric_expression , ")" , block } ,
    [ "else" , block ] ;

```
Поддерживает цепочки else if.  Висячий else прикрепляется к ближайшему if.

### Цикл while

```
while_statement =
    "while" , "(" , numeric_expression , ")" , block ;
```

### Цикл for

```
for_statement =
    "for" , "(" ,[ init ] , ";" , [ numeric_expression ] , ";" , [ update ] , ")" , block ;

init   = variable_declaration | assignment ;
update = assignment ;
```
Инициализация ( let i = 0), условие, обновление (i = i + 1 или i++ через постфикс).

## 7. Выражения

Присваивание не является выражением, а только инструкцией.  
Примеры допустимых выражений:

```
a + b
(a - 3) * 2
```


